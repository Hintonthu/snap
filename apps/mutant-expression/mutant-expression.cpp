#include "stdafx.h"

#include "GenomeIndex.h"
#include "exit.h"
#include "SAM.h"
#include "FixedSizeMap.h"


const Genome *ReferenceGenome = NULL;

void usage()
{
    fprintf(stderr, "usage: mutant-expression index inputFile {-h} {-vcf|-germline|-selectedReads DNAReadsFilename RNAReadsFilename} {-consolodatedInput inputFilename}\n");
    fprintf(stderr, "inputFile is generated by ExpressionMetadata or FilterVCF.\n");
    fprintf(stderr, "-h means to print the header\n");
    fprintf(stderr, "-vcf means the input file is vcf-style rather than maf-style (i.e, it was made by FilterVCF rather than ExpressionMetadata).\n");
    fprintf(stderr, "-germline means this is a germline variant call style input file.\n");
    fprintf(stderr, "-selectedReads means this is a selected reads style input file, and must be followed by the pathname of the experiments file.\n");
    fprintf(stderr, "consolodated input is a file generated by GenerateConsolodatedExtractedReads.  You can have as many of these as you'd like, and they'll\n");
    fprintf(stderr, "be treated as a single input source.\n");
    soft_exit(1);
}

bool 
BreakLineIntoPiecesBasedOnTabs(char *inputBuffer, char **piece, int nPieces) {
    //
    // Parse the line into tab separated pieces.
    //

    piece[0] = inputBuffer;

    for (int whichPiece = 1; whichPiece < nPieces; whichPiece++) {
        piece[whichPiece] = strchr(piece[whichPiece - 1], '\t');
        if (NULL == piece[whichPiece]) {
            return false;
        }
        *piece[whichPiece] = '\0';  // Turn the tab into a null, so we have separate strings for each piece
        piece[whichPiece]++; // And point at the real beginning of the string.
    }

    return true;
}

const char *translateAlternateChromName(const char *inputName)
{
    if (!strcmp(inputName, "GL000191.1")) return "chr1_gl000191_random";
    if (!strcmp(inputName, "GL000192.1")) return "chr1_gl000192_random";
    if (!strcmp(inputName, "GL000193.1")) return "chr4_gl000193_random";
    if (!strcmp(inputName, "GL000194.1")) return "chr4_gl000194_random";
    if (!strcmp(inputName, "GL000195.1")) return "chr7_gl000195_random";
    if (!strcmp(inputName, "GL000205.1")) return "chr17_gl000205_random";
    if (!strcmp(inputName, "GL000209.1")) return "chr19_gl000209_random";
    if (!strcmp(inputName, "GL000211.1")) return "chrUn_gl000211";
    if (!strcmp(inputName, "GL000212.1")) return "chrUn_gl000212";
    if (!strcmp(inputName, "GL000213.1")) return "chrUn_gl000213";
    if (!strcmp(inputName, "GL000214.1")) return "chrUn_gl000214";
    if (!strcmp(inputName, "GL000218.1")) return "chrUn_gl000218";
    if (!strcmp(inputName, "GL000219.1")) return "chrUn_gl000219";
    if (!strcmp(inputName, "GL000220.1")) return "chrUn_gl000220";
    if (!strcmp(inputName, "GL000229.1")) return "chrUn_gl000229";
    if (!strcmp(inputName, "GL000237.1")) return "chrUn_gl000237";
    if (!strcmp(inputName, "GL000241.1")) return "chrUn_gl000241";


    return NULL;
}

template<typename T>
class StringHash
{
public:
    inline _uint64 operator() (T string) {
        _uint64 value = 0;

        size_t len = strlen(string);
        for (int i = 0; i < len; i++) {
            value = value * 131 + string[i];
        }

        return value;
    }
};

struct RefSeqList {
    char *refSeqId;
    RefSeqList *next;
};

FixedSizeMap<const char *, RefSeqList *, StringHash<const char *> > *HugoToRefSeq = NULL;

class SamLineReader {
public:
    virtual char* fgets(char *buffer, int bufferSize) = 0;
    virtual ~SamLineReader() {};
    virtual bool setFile(const char *filename) = 0;
};

class StdioSamLineReader : public SamLineReader {
public:
    StdioSamLineReader();
    virtual ~StdioSamLineReader();
    virtual char * fgets(char *buffer, int bufferSize);
    virtual bool setFile(const char *filename);
private:
    FILE *file;
};

StdioSamLineReader::StdioSamLineReader()
{
    file = NULL;
}

StdioSamLineReader::~StdioSamLineReader()
{
    if (NULL != file) {
        fclose(file);
    }
}

char *
StdioSamLineReader::fgets(char *buffer, int bufferSize)
{
    if (NULL == file) {
        return NULL;
    }

    return ::fgets(buffer, bufferSize, file);
}

bool
StdioSamLineReader::setFile(const char *filename)
{
    if (NULL != file) {
        fclose(file);
    }

    file = fopen(filename, "r");
    return NULL != file;
}

class CondensedFileSamLineReader : public SamLineReader {
public:
    CondensedFileSamLineReader(const char *filename);
    ~CondensedFileSamLineReader();
    virtual char * fgets(char *buffer, int bufferSize);
    virtual bool setFile(const char *filename);
private:

    HANDLE hFile;
    int nContainedFiles;
    char **containedFiles;

    char *index;

    int currentChunkBufferSize;
    char *currentChunk;
    int currentChunkSize;
    int offsetInCurrentChunk;
    
};

CondensedFileSamLineReader::CondensedFileSamLineReader(const char *filename)
{
    currentChunk = NULL;
    currentChunkSize = 0;
    offsetInCurrentChunk = 0;
    currentChunkBufferSize = 0;

    hFile = CreateFile(filename, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
    if (INVALID_HANDLE_VALUE == hFile) {
        fprintf(stderr, "Unable to open file '%s', %d\n", filename, GetLastError());
        exit(1);
    }

    //
    // Read in the index.
    //
    char *indexFileName = new char[strlen(filename) + 7];
    sprintf(indexFileName, "%s.index", filename);
    HANDLE hIndex = CreateFile(indexFileName, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
    if (INVALID_HANDLE_VALUE == hIndex) {
        fprintf(stderr, "Unable to open index file '%s', %d\n", indexFileName, GetLastError());
        exit(1);
    }

    BY_HANDLE_FILE_INFORMATION fileInfo[1];
    if (!GetFileInformationByHandle(hIndex, fileInfo)) {
        fprintf(stderr, "GetFileInformationByHandle failed, %d\n", GetLastError());
        exit(1);
    }

    LARGE_INTEGER liIndexSize;
    liIndexSize.HighPart = fileInfo->nFileSizeHigh;
    liIndexSize.LowPart = fileInfo->nFileSizeLow;

    _int64 indexSize = liIndexSize.QuadPart;

    char *index = new char[indexSize];
    
    for (_int64 bytesRead = 0; bytesRead < indexSize;) {
        DWORD amountToRead;
        const DWORD maxReadSize = 64 * 1024 * 1024;
        DWORD bytesThisRead;

        if (indexSize - bytesRead < maxReadSize) {
            amountToRead = (DWORD)(indexSize - bytesRead);
        }
        else {
            amountToRead = maxReadSize;
        }

        if (!ReadFile(hIndex, index + bytesRead, amountToRead, &bytesThisRead, NULL)) {
            fprintf(stderr, "Error reading index, %d\n", GetLastError());
            exit(1);
        }

        if (0 == bytesThisRead) {
            fprintf(stderr, "Got 0 length read of index\n");
            exit(1);
        }

        bytesRead += bytesThisRead;
    }

    //
    // Count the lines, which are essentially contained files.
    //

    nContainedFiles = 0;
    for (char *ptr = index; ptr < index + indexSize; ptr++) {
        if (*ptr == '\n') {
            nContainedFiles++;
        }
    }

    containedFiles = new char*[nContainedFiles];
    int whichContainedFile = 1;
    containedFiles[0] = index;
    int nTabs = 0;
    for (char *ptr = index; ptr < index + indexSize; ptr++) {
        if (*ptr == '\r') { // Blow away the return in CRLF 
            *ptr = '\0';
        } else  if (*ptr == '\n') {
            *ptr = '\0';
            if (2 != nTabs) {
                fprintf(stderr, "Failed to parse index line %d, expected 2 tabs got %d\n", whichContainedFile - 1, nTabs);
                exit(1);
            }
            if (whichContainedFile < nContainedFiles) {
                containedFiles[whichContainedFile] = ptr + 1;
            }
            nTabs = 0;
            whichContainedFile++;
        } else if (*ptr == '\t') {
            nTabs++;
            *ptr = '\0';    // Split apart the fields, too.
        }
    }
}

CondensedFileSamLineReader::~CondensedFileSamLineReader()
{
    CloseHandle(hFile);
    delete[] index;
    delete[] currentChunk;
    delete[] containedFiles;
}

char *
CondensedFileSamLineReader::fgets(char *buffer, int bufferSize)
{
    if (offsetInCurrentChunk >= currentChunkSize) {
        return NULL;
    }

    size_t bytesCopied = 0;
    while (bytesCopied < bufferSize - 1 /* allows space for terminating null */ && offsetInCurrentChunk < currentChunkSize) {
        if (currentChunk[offsetInCurrentChunk] != '\r') {   // We just never copy the damn carriage returns
            buffer[bytesCopied] = currentChunk[offsetInCurrentChunk];
            bytesCopied++;
        }
        offsetInCurrentChunk++;

        if (bytesCopied > 0 && buffer[bytesCopied - 1] == '\n') {
            break;
        }
    }

    buffer[bytesCopied] = '\0';
    return buffer;
}

bool
CondensedFileSamLineReader::setFile(const char *filename)
{
    //
    // Do a binary search.
    //
    int min = 0;
    int max = nContainedFiles - 1;

    for (;;) {
        if (min > max) {
            //
            // It wasn't here.
            //
            return false;
        }

        int candidate = (min + max) / 2;

        int whichWay = _stricmp(filename, containedFiles[candidate]);

        if (0 == whichWay) {
            //
            // Parse the line.  It's format is filename offset size, each in a separate string (tabs in the input file were converted when we read it)
            //
            char *ptr = containedFiles[candidate];
            while (*ptr != '\0') {
                ptr++;
            }
            ptr++;

            LARGE_INTEGER liOffset;
            if (1 != sscanf(ptr, "%lld", &liOffset.QuadPart)) {
                fprintf(stderr, "Unable to parse offset in index for included file %d, '%s'\n", candidate, ptr);
            }

            while (*ptr != '\0') {
                ptr++;
            }
            ptr++;

            if (1 != sscanf(ptr, "%d", &currentChunkSize)) {
                fprintf(stderr, "Unable to parse length in index for included file %d, '%s'\n", candidate, ptr);
            }

            if (currentChunkBufferSize < currentChunkSize + 1) {
                delete[] currentChunk;
                currentChunk = new char[currentChunkSize + 1];
                currentChunkBufferSize = currentChunkSize + 1;
            }


            if (!SetFilePointerEx(hFile, liOffset, NULL, FILE_BEGIN)) {
                fprintf(stderr, "SetFilePointerEx failed, %d\n", GetLastError());
                exit(1);
            }

            DWORD bytesRead;
            if (!ReadFile(hFile, currentChunk, currentChunkSize, &bytesRead, NULL)) {
                fprintf(stderr, "Error reading data file, %d\n", GetLastError());
                exit(1);
            }
            currentChunk[currentChunkSize] = '\0';

            offsetInCurrentChunk = 0;

            return true;
        }

        if (whichWay < 0) {
            max = candidate - 1;
        } else {
            min = candidate + 1;
        }
    }
}

class MultiSourceSamLineReader : public SamLineReader {
public:
    MultiSourceSamLineReader();
    ~MultiSourceSamLineReader();
    virtual char * fgets(char *buffer, int bufferSize);
    virtual bool setFile(const char *filename);
    virtual void AddSource(SamLineReader *newSource);

private:
    int nSources;
    int currentSource;
    SamLineReader **sources;
};

MultiSourceSamLineReader::MultiSourceSamLineReader()
{
    nSources = 0;
    currentSource = -1;
    sources = NULL;
}

MultiSourceSamLineReader::~MultiSourceSamLineReader()
{
    for (int i = 0; i < nSources; i++) {
        delete sources[i];
    }
    delete [] sources;
}

char *
MultiSourceSamLineReader::fgets(char *buffer, int bufferSize)
{
    if (-1 == currentSource) {
        return NULL;
    }

    return sources[currentSource]->fgets(buffer, bufferSize);
}

bool
MultiSourceSamLineReader::setFile(const char *filename)
{
    for (int i = 0; i < nSources; i++) {
        if (sources[i]->setFile(filename)) {
            currentSource = i;
            return true;
        }
    }

    currentSource = -1;
    return false;
}

void
MultiSourceSamLineReader::AddSource(SamLineReader *newSource)
{
    SamLineReader **newSources = new SamLineReader *[nSources + 1];
    for (int i = 0; i < nSources; i++) {
        newSources[i] = sources[i];
    }
    newSources[nSources] = newSource;
    nSources++;

    delete[] sources;
    sources = newSources;
}



int main(int argc, char* argv[])
{
    if (argc < 3) usage();

    bool printHeader = false;
    bool vcfStyleInput = false;
    bool germlineStyleInput = false;
    bool selectedReadsStyleInput = false;

    char *selectedReadsDNAAnalysisId = NULL;
    char *selectedReadsRNAAnalysisId = NULL;

    SamLineReader *reader = NULL;

    for (int i = 3; i < argc; i++) {
        if (!strcmp(argv[i], "-h")) {
            printHeader = true;
        } else if (!strcmp(argv[i], "-vcf")) {
            if (germlineStyleInput || selectedReadsStyleInput) {
                fprintf(stderr, "-vcf, -germline and -selectedReads are mutually exclusive\n");
                usage();
            }
            vcfStyleInput = true;
        } else if (!strcmp(argv[i], "-germline")) {
            if (vcfStyleInput || selectedReadsStyleInput) {
                fprintf(stderr, "-vcf, -germline and -selectedReads are mutually exclusive\n");
                usage();
            }
            germlineStyleInput = true;
        } else if (!strcmp(argv[i], "-consolodatedInput")) {
            if (i + 1 >= argc) usage();
            if (NULL == reader) {
                reader = new MultiSourceSamLineReader();
            }
            MultiSourceSamLineReader *msReader = (MultiSourceSamLineReader *)reader;
            msReader->AddSource(new CondensedFileSamLineReader(argv[i + 1]));
            i++;
        } else if (!strcmp(argv[i], "-selectedReads")) {
            if (i + 2 >= argc) usage();
            if (vcfStyleInput || germlineStyleInput) {
                fprintf(stderr, "-vcf, -germline and -selectedReads are mutually exclusive\n");
                exit(1);
            }
            selectedReadsDNAAnalysisId = argv[i + 1];
            selectedReadsRNAAnalysisId = argv[i + 2];

            if (strlen(selectedReadsDNAAnalysisId) != 36 || strlen(selectedReadsRNAAnalysisId) != 36) {
                fprintf(stderr, "Selected DNA and RNA analysis IDs must be GUIDs.");
                exit(1);
            }
            selectedReadsStyleInput = true;
            i += 2;
        } else {
            usage();
        }

    }
    int lineNumber = 0;

    if (NULL == reader) {
        reader = new StdioSamLineReader;
    }

    static const char *genomeSuffix = "Genome";
    size_t filenameLen = strlen(argv[1]) + 1 + strlen(genomeSuffix) + 1;
    char *fileName = new char[strlen(argv[1]) + 1 + strlen(genomeSuffix) + 1];
    snprintf(fileName, filenameLen, "%s%c%s", argv[1], PATH_SEP, genomeSuffix);
    const Genome *genome = Genome::loadFromFile(fileName, 0);
    if (NULL == genome) {
        fprintf(stderr, "Unable to load genome from file '%s'\n", fileName);
        return -1;
    }
    delete[] fileName;
    fileName = NULL;


    if (printHeader) {
        if (vcfStyleInput) {
            printf("Cancer_Type\tParticipantID\tDisease Abbr\tReference Assembly\tNormal DNA Analysis ID\tNormal DNA Filename\tNormal RNA Analysis ID\t"
                "Normal RNA Filename\tTumor RNA AnanlysisID\tTumor RNA Filename\tExtracted Reads Normal Filename\tExtracted Reads Tumor Filename\tChrom\tPos\tID\tRef\tAlt\tQual\tFilter\tInfo\tFormat\t\t" // double \t is for 
                "n_Matching_Reference (tumor)\tn_Matching_Variant (tumor)\tn_Matching_Neither (tumor)\tn_Matching_Both (tumor)\tn_Matching_Reference (normal)\tn_Matching_Variant (normal)\tn_Matching_Neither (normal)\tn_Matching_Both (normal)\n");
        } else if (germlineStyleInput) {
            printf("Cancer_type\tDNA_Input_filename\tRNA_Input_Filename\tAnalysis_id\tchromosome\tpos\tID\tref\talt\tqual\tfilter\tvcfInfo\tvcfInfo2\tvcfInfo3\treference\t"
                "n_Matching_Reference (DNA)\tn_Matching_Variant (DNA)\tn_Matching_Neither (DNA)\tn_Matching_Both (DNA)\tn_Matching_Reference (RNA)\tn_Matching_Variant (RNA)\tn_Matching_Neither (RNA)\tn_Matching_Both (RNA)\n");
        } else if (selectedReadsStyleInput) {
            printf("Contig\tloc\tcontig\tloc\tid\tref\talt\tqual\tfilter\tinfo\tformat\t??\tn_Matching_Reference (DNA)\tn_Matching_Variant (DNA)\tn_Matching_Neither (DNA)\tn_Matching_Both (DNA)\tn_Matching_Reference (RNA)\tn_Matching_Variant (RNA)\tn_Matching_Neither (RNA)\tn_Matching_Both (RNA)\n");
        } else {
            printf("Cancer_Type\tLocal_file_name\tHugo_Symbol\tEntrez_Gene_Id\tCenter\tNCBI_Build\tChromosome\tStart_Position\tEnd_Position\tStrand\tVariant_Classification\tVariant_Type\tReference_Allele\tTumor_Seq_Allele_1\tTumor_Seq_Allele_2\tdbSNP_RS\tdbSNP_Val_Status\t"
                "Tumor_Sample_Barcode\tMatched_Norm_Sample_Barcode\tMatch_Norm_Seq_Allele1\tMatch_Norm_Seq_Allele2\tTumor_Validation_Allele1\tTumor_Validation_Allele2\tMatch_Norm_Validation_Allele1\tMatch_Norm_Validation_Allele2\tVerification_Status\t"
                "Validation_Status\tMutation_Status\tSequencing_Phase\tSequence_Source\tValidation_Method\tScore\tBAM_File\tSequencer\tTumor_Sample_UUID\tMatched_Norm_Sample_UUID\tFile_Name\tArchive_Name\tLine_Number\t"
                "n_Matching_Reference\tn_Matching_Tumor\tn_Matching_Neither\tn_Matching_Both\n");
        }
    }

    ReferenceGenome = genome;

    FILE *inputFile = fopen(argv[2], "r");

    if (NULL == inputFile) {
        fprintf(stderr, "Unable to open input file '%s'\n", argv[2]);
        soft_exit(1);
    }

    const size_t inputLineSize = 20000; // We're among friends, don't worry about buffer overflows

    char inputBuffer[inputLineSize];
    char rawInputBuffer[inputLineSize];
    //fgets(inputBuffer, inputLineSize - 1, inputFile);   // Skip the header

    const int maxInputLinePieces = 38;
    char *piece[maxInputLinePieces];

    int mutationNumber = 1; // Because excel starts at 1

    int noSAMFile = 0;
    int nMT = 0;
    int nWrongClass = 0;
    int nValidationProblems = 0;
    int nSAMProblems = 0;
    lineNumber = 0;

    struct MissingGUID {
        char guid[37];
        MissingGUID *next;
    };

    MissingGUID *missingGUIDs = NULL;


    int RNAFileName;
    int Chrom;
    int StartPosition;
    int VariantClass;
    int VariantType;
    int Reference_Allele;
    int Tumor_Seq_Allele_2;
    int nInputLinePieces;
    int DiseaseType;

    if (vcfStyleInput) {
        RNAFileName = -1;   // Depends on tumor/normal
        Chrom = 11;
        StartPosition = 12;
        VariantClass = -1; // Have to figure from context
        VariantType = -1; // N/A
        Reference_Allele = 14;
        Tumor_Seq_Allele_2 = 15;
        nInputLinePieces = 20;
        DiseaseType = 1;
    } else if (germlineStyleInput) {
        RNAFileName = -1;   // Depends on which pass
        Chrom = 4;
        StartPosition = 5;
        VariantClass = -1;
        VariantType = -1;
        Reference_Allele = 7;
        Tumor_Seq_Allele_2 = 8;
        nInputLinePieces = 12;
        DiseaseType = 0;
    } else if (selectedReadsStyleInput) {
        RNAFileName = -1;   // Depends on which pass, and comes from command line anyway
        Chrom = 0;
        StartPosition = 1;
        VariantClass = -1;  // Always an SNV, we'll assume missense though that's not clear/well defined for these
        VariantType = -1;
        Reference_Allele = 5;
        Tumor_Seq_Allele_2 = 6;
        nInputLinePieces = 11;
        DiseaseType = -1;
    } else {
        RNAFileName = 0;
        Chrom = 5;
        StartPosition = 6;
        VariantClass = 9;
        VariantType = 10;
        Reference_Allele = 11;
        Tumor_Seq_Allele_2 = 13;
        nInputLinePieces = 38;
        DiseaseType = -1;
    }

    const int nPasses = 2;

    char selectedReadsSAMFileNameBuffer[1000];

    bool seenDone = false;

    while (fgets(inputBuffer, inputLineSize - 1, inputFile)) {
        int nMatchingReference[nPasses] = { 0, 0 };
        int nMatchingMutation[nPasses] = { 0, 0 };
        int nMatchingNeither[nPasses] = { 0, 0 };
        int nMatchingBoth[nPasses] = { 0, 0 };



        lineNumber++;
        if (lineNumber % 10000 == 0) {
            fprintf(stderr, ".");
        }

        if (selectedReadsStyleInput && 1 == lineNumber) {
            //
            // Skip the header line.
            //
            continue;
        }

        if (seenDone) {
            fprintf(stderr, "Input file continues past done\n");
            break;
        }

        if (!strcmp("**done**\n", inputBuffer)) {
            seenDone = true;
            continue;
        }

        memcpy(rawInputBuffer, inputBuffer, inputLineSize);

        if (!BreakLineIntoPiecesBasedOnTabs(inputBuffer, piece, nInputLinePieces)) {
            fprintf(stderr, "Malformed line '%s', number %d ignoring.\n", rawInputBuffer, mutationNumber);
            goto doneWithMutation;
        }

        //
        // Now process the mutation.
        //



        if (vcfStyleInput && !strcmp(piece[0], "ParticipantID")) {
            // Skip the header line.
            continue;
        }

        bool hasNormalRNA = false;
        for (int pass = 0; pass < ((vcfStyleInput || germlineStyleInput || selectedReadsStyleInput) ? 2 : 1); pass++) {
            if (vcfStyleInput) {
                if (0 == pass) {
                    RNAFileName = 10;
                } else {
                    RNAFileName = 9;
                    if (!strcmp("", piece[RNAFileName])) {
                        continue;   // No normal RNA for this participant
                    }
                    hasNormalRNA = true;
                }
            } else if (germlineStyleInput) {
                if (0 == pass) {
                    RNAFileName = 1;    // Actually, DNA
                }
                else {
                    RNAFileName = 2;    // Really RNA, this time.
                }
            }

            char *SAMFileName;
            char *chrom;
           
            if (selectedReadsStyleInput) {
                //
                // Strip the "chr" off of the chromosome name, if it exists.
                //
                if (strlen(piece[0]) > 3 && piece[0][0] == 'c' && piece[0][1] == 'h' && piece[0][2] == 'r' && strlen(piece[0]) <= 5) {
                    chrom = piece[0] + 3;
                } else {
                    chrom = piece[0];
                }
                sprintf(selectedReadsSAMFileNameBuffer, "%s-%s-%s", (pass == 0) ? selectedReadsDNAAnalysisId : selectedReadsRNAAnalysisId, chrom, piece[1]);
                SAMFileName = selectedReadsSAMFileNameBuffer;
            } else {
                SAMFileName = piece[RNAFileName];
                chrom = piece[Chrom];
            }

            if (!reader->setFile(SAMFileName)) {

                bool worked = false;

                if (selectedReadsStyleInput) {
                    //
                    // Try adding "chr" onto the chromosome name.
                    //
                    sprintf(selectedReadsSAMFileNameBuffer, "%s-chr%s-%s", (pass == 0) ? selectedReadsDNAAnalysisId : selectedReadsRNAAnalysisId, chrom, piece[1]);
                    worked = reader->setFile(SAMFileName);  // Recall that SAMFileName just points at the buffer we wrote into.
                }

                if (!worked) {
                    fprintf(stderr, "Unable to open SAM file %s, line %d\n", SAMFileName, lineNumber);

                    if (!selectedReadsStyleInput) {
                        //
                        // Keep track of the GUID from the filename so that we can list them at the end.
                        //
                        const char *guid = strchr(SAMFileName, '\\');
                        if (NULL != guid) {
                            guid++;
                            if (strlen(guid) >= 36) {
                                if (NULL == missingGUIDs || memcmp(missingGUIDs->guid, guid, 36)) {
                                    MissingGUID *next = new MissingGUID;
                                    memcpy(next->guid, guid, 36);
                                    next->guid[36] = '\0';
                                    next->next = missingGUIDs;
                                    missingGUIDs = next;
                                }
                            }
                        }
                    }
                    noSAMFile++;
                    goto doneWithMutation;
                }
            }

            unsigned mutationStartPos = atoi(piece[StartPosition]);
            if (0 == mutationStartPos) {
                fprintf(stderr, "Got 0 mutation start pos from field '%s' on mutation line number %d, ignoring mutation\n", piece[StartPosition], mutationNumber);
                goto doneWithMutation;
            }

            if (!strcmp("M", piece[Chrom]) || !strcmp("MT", piece[Chrom])) {
                //
                // Mitochondrial variations aren't useful with this method.  Most of them were stripped earlier, but I only
                // checked for "MT" as the chromosome name there, and some of them are just "M".  Drop them now.
                //
                nMT++;
                goto doneWithMutation;
            }

#if 0

            if (!strcmp("RNA", piece[VariantClass]) || !strcmp("Silent", piece[VariantClass])) {
                //
                // I'm not quite sure what an RNA variant is, but oddly, it doesn't seem to show up in RNA.
                // Silent variants aren't interesting, because they don't affect the protein and so probably
                // aren't real variants at all, and so you wouldn't expect to see loss of the other copy.
                //
                nWrongClass++;
                goto doneWithMutation;
            }

#endif // 0

            GenomeLocation mutationContigStartLocation;
            if (!ReferenceGenome->getLocationOfContig(piece[Chrom], &mutationContigStartLocation)) {
                //
                // try prefixing it with "chr"
                //
                char chromosomeName[1000];
                sprintf(chromosomeName, "chr%s", piece[Chrom]);
                if (!ReferenceGenome->getLocationOfContig(chromosomeName, &mutationContigStartLocation)) {
                    //
                    // Some of the alternate alleles have different names in the MAF files from our build.  Translate them.
                    //
                    const char *alternateChromName = translateAlternateChromName(piece[Chrom]);
                    if (NULL == alternateChromName || !ReferenceGenome->getLocationOfContig(alternateChromName, &mutationContigStartLocation)) {
                        fprintf(stderr, "Couldn't find contig '%s' for mutation number %d\n", piece[Chrom], mutationNumber);
                        goto doneWithMutation;
                    }
                }
            }

            GenomeLocation mutationLocation = mutationContigStartLocation + mutationStartPos - 1;   // -1 is because of 1-based reference

            const char *refAtMutation = ReferenceGenome->getSubstring(mutationLocation, 1);
            if (NULL == refAtMutation) {
                fprintf(stderr, "Couldn't get reference data for contig '%s', location %d, mutation number %d\n", piece[Chrom], mutationStartPos, mutationNumber);
                goto doneWithMutation;
            }

            const size_t matchAreaSize = 30;
            char referenceMatch[matchAreaSize];
            char mutantMatch[matchAreaSize];
            memset(mutantMatch, 0, matchAreaSize);

            unsigned matchAreaStartPos;
            matchAreaStartPos = (unsigned)__max(1, ((int)mutationStartPos) - 10);
            const char *refAtMatchStart;
            refAtMatchStart = ReferenceGenome->getSubstring(mutationLocation + matchAreaStartPos - mutationStartPos, 1);

            memcpy(referenceMatch, refAtMatchStart, matchAreaSize);

            bool mutationIsInsertion = false;
            bool mutationIsDeletion = false;
            bool mutationIsSNV = false;

            const char *variantType;
            if (vcfStyleInput || germlineStyleInput || selectedReadsStyleInput) {
                variantType = "SNP";    // We only take SNP from the VCF
            } else {
                variantType = piece[VariantType];
            }

            if (!strcmp(variantType, "DEL")) {
                mutationIsDeletion = true;
                if (strcmp(piece[Tumor_Seq_Allele_2], "-")) {
                    fprintf(stderr, "Mutation is a deletion, but has a non-empty tumor allele '%s', line number %d\n", piece[Tumor_Seq_Allele_2], lineNumber);
                    nValidationProblems++;
                    goto doneWithMutation;
                }
                size_t deletionLength = strlen(piece[Reference_Allele]);
                memcpy(mutantMatch, referenceMatch, mutationStartPos - matchAreaStartPos);
                memcpy(mutantMatch + mutationStartPos - matchAreaStartPos, refAtMutation + deletionLength, matchAreaSize - (mutationStartPos - matchAreaStartPos));
            }
            else if (!strcmp(variantType, "INS")) {
                mutationIsInsertion = true;
                if (strcmp(piece[Reference_Allele], "-")) {
                    fprintf(stderr, "Mutation is insertion but has a reference allele, mutation number %d\n", mutationNumber);
                    nValidationProblems++;
                    goto doneWithMutation;
                }
                size_t insertionLength = strlen(piece[Tumor_Seq_Allele_2]);
                size_t preMutantBaseCount = (size_t)(mutationStartPos - matchAreaStartPos + 1);
                memcpy(mutantMatch, referenceMatch, preMutantBaseCount);
                if (insertionLength + preMutantBaseCount >= matchAreaSize) {
                    //
                    // The insertion fills (or overflows) the rest of the match area
                    //
                    memcpy(mutantMatch + preMutantBaseCount, piece[Tumor_Seq_Allele_2], matchAreaSize - preMutantBaseCount);
                }
                else {
                    //
                    // The insertion foes not fill the rest of the match area
                    //
                    memcpy(mutantMatch + preMutantBaseCount, piece[Tumor_Seq_Allele_2], insertionLength);
                    memcpy(mutantMatch + preMutantBaseCount + insertionLength, refAtMutation + 1, matchAreaSize - preMutantBaseCount - insertionLength);
                }
            }
            else if (!strcmp(variantType, "SNP") || !strcmp(variantType, "DNP") || !strcmp(variantType, "TNP")) {
                // Single, double or triple nucleotide polymorphism.

                int polymorphismLength;
                if (!strcmp(variantType, "SNP")) {
                    polymorphismLength = 1;
                }
                else if (!strcmp(variantType, "DNP")) {
                    polymorphismLength = 2;
                }
                else {
                    polymorphismLength = 3;
                }
                mutationIsSNV = true;
                if (strlen(piece[Reference_Allele]) != polymorphismLength && strlen(piece[Tumor_Seq_Allele_2]) != polymorphismLength) {
                    fprintf(stderr, "S/D/TNP with ref and/or tumor wrong length: type %s ref %s, tumor %s, mutation number %d\n", variantType, piece[Reference_Allele], piece[Tumor_Seq_Allele_2], mutationNumber);
                    nValidationProblems++;
                    goto doneWithMutation;
                }
                if (memcmp(refAtMutation, piece[Reference_Allele], polymorphismLength)) {
                    fprintf(stderr, "Reference doesn't match expected reference allele (type %s), %c != %c, mutation number %d, chromosome %s, location %d\n", variantType, *refAtMutation, piece[Reference_Allele][0], mutationNumber, piece[Chrom], mutationStartPos);
                    nValidationProblems++;
                    goto doneWithMutation;
                }
                if (!memcmp(piece[Tumor_Seq_Allele_2], refAtMutation, polymorphismLength)) {
                    fprintf(stderr, "Mutation is %s, but matches reference, mutation number %d\n", variantType, mutationNumber);
                    nValidationProblems++;
                    goto doneWithMutation;
                }
                memcpy(mutantMatch, referenceMatch, matchAreaSize);
                mutantMatch[mutationStartPos - matchAreaStartPos] = piece[Tumor_Seq_Allele_2][0];
            }
            else {
                fprintf(stderr, "Unknown mutation type: '%s', mutation number %d\n", variantType, mutationNumber);
                nValidationProblems++;
                goto doneWithMutation;
            }



            char samLine[inputLineSize];
            int samFileLineNumber = 0;
            while (reader->fgets(samLine, inputLineSize - 1)) {
                const int Flag = 1;
                const int RName = 2;
                const int Pos = 3;
                const int Cigar = 5;
                const int Seq = 9;
                bool matchesReference = true;
                bool matchesMutant = true;
                bool checkedMutationLocation = false;

                samFileLineNumber++;    // Increment first for 1-based

                char *samPieces[Seq + 2];
                if (!BreakLineIntoPiecesBasedOnTabs(samLine, samPieces, Seq + 2)) {
                    fprintf(stderr, "Unparsable SAM line in file '%s', line number %d, line '%s'\n", SAMFileName, samFileLineNumber, samLine);
                    nSAMProblems++;
                    goto doneWithMutation;
                }

                unsigned samFlags = atoi(samPieces[Flag]);
                if (samFlags & SAM_UNMAPPED) {
                    //
                    // This read isn't mapped, it's probably the mate pair of a read that was mapped. Ignore it.
                    //
                    continue;
                }

                unsigned pos = atoi(samPieces[Pos]);
                if (pos > mutationStartPos) {
                    //
                    // This read is mapped after the end of the mutation.  Ignore it.
                    //
                    continue;
                }

                //
                // Walk through the read and CIGAR string and find the base that's mapped at the mutation position.
                //

                int offsetInRead = 0;
                unsigned currentReferencePos = atoi(samPieces[Pos]);
                unsigned currentReadPos = currentReferencePos;
                if (currentReferencePos == 0) {
                    fprintf(stderr, "Got illegal POS ('%s') in mapped sam line, file '%s', line %d\n", samPieces[Pos], SAMFileName, samFileLineNumber);
                    nSAMProblems++;
                    goto doneWithMutation;
                }

                size_t seqLength = strlen(samPieces[Seq]);

                //
                // Walk through the read and CIGAR string
                //
                size_t offsetInCigarString = 0;
                const char *cigarString = samPieces[Cigar];

                while (cigarString[offsetInCigarString] != '\0') {
                    _ASSERT(currentReadPos <= mutationStartPos);

                    unsigned cigarCount = atoi(cigarString + offsetInCigarString);
                    if (0 == cigarCount && cigarString[offsetInCigarString] != '0') { // Yes, there's actually a CIGAR string that's 27M0N48M
                        fprintf(stderr, "Unable to properly parse CIGAR string '%s', sam file '%s', line %d\n", cigarString, SAMFileName, samFileLineNumber);
                        nSAMProblems++;
                        goto doneWithMutation;
                    }

                    while (cigarString[offsetInCigarString] >= '0' && cigarString[offsetInCigarString] <= '9') {
                        offsetInCigarString++;
                    }

                    char op = cigarString[offsetInCigarString];
                    offsetInCigarString++;

                    switch (op) {

                    case 'S':
                        offsetInRead += cigarCount;
                        break;

#if 0
                    case 'M':
                        //
                        // See if this includes the mutant base.
                        //
                        if (currentReadPos + cigarCount > mutationStartPos) {
                            //
                            // The mutation is in this chunk of read.
                            //
                            if (samPieces[Seq][offsetInRead + mutationStartPos - currentReadPos] == *refAtMutation) {
                                //
                                // It matches the reference.
                                //
                                nMatchingReference++;
                            }
                            else if (mutationIsSNV && samPieces[Seq][offsetInRead + mutationStartPos - currentReadPos] == piece[Tumor_Seq_Allele_2][0]) {
                                nMatchingMutation++;
                            }
                            else {
                                nMatchingNeither++;
                            }

                        }

                        //
                        // Move along equal amounts in read, reference and read string.
                        //
                        currentReadPos += cigarCount;
                        offsetInRead += cigarCount;
                        currentReferencePos += cigarCount;
                        break;

                    case 'I':
                        if (currentReadPos == mutationStartPos) {
                            if (mutationIsInsertion) {
                                //
                                // See if the bases in the read match the bases in the mutation.
                                //
                                if (seqLength - offsetInRead >= strlen(piece[Tumor_Seq_Allele_2]) && !memcmp(samPieces[Seq] + offsetInRead, piece[Tumor_Seq_Allele_2], strlen(piece[Tumor_Seq_Allele_2]))) {
                                    nMatchingMutation++;
                                }
                                else {
                                    nMatchingNeither++; // Insertions never match the reference.
                                }
                            }
                            else {
                                nMatchingNeither++;
                            }
                            currentReadPos++;   // Just to get us out of processing this read
                        }

                        offsetInRead += cigarCount;
                        break;


                    case 'D':
                        if (currentReadPos + cigarCount > mutationStartPos) {
                            if (mutationIsDeletion) {
                                nMatchingMutation++;
                            }
                            else {
                                nMatchingNeither++;
                            }
                        }

                        currentReadPos += cigarCount;
                        offsetInRead += cigarCount;
                        break;


#else // 0
                    case 'M':
                        if (currentReadPos + cigarCount > matchAreaStartPos) {
                            //
                            // This covers at least some of the match area
                            //
                            unsigned firstPos = __max(currentReadPos, matchAreaStartPos);
                            unsigned lastPos = __min(currentReadPos + cigarCount, matchAreaStartPos + matchAreaSize);

                            for (unsigned pos = firstPos; pos < lastPos; pos++) {
                                matchesReference &= (samPieces[Seq][offsetInRead + pos - currentReadPos] == referenceMatch[pos - matchAreaStartPos]);
                                matchesMutant &= (samPieces[Seq][offsetInRead + pos - currentReadPos] == mutantMatch[pos - matchAreaStartPos]);
                            }

                            if (currentReadPos <= mutationStartPos && currentReadPos + cigarCount > mutationStartPos) {
                                checkedMutationLocation = true;
                            }
                        }

                        //
                        // Move along equal amounts in read, reference and read string.
                        //
                        currentReadPos += cigarCount;
                        offsetInRead += cigarCount;
                        currentReferencePos += cigarCount;
                        break;

                    case 'D':

                        currentReferencePos += cigarCount;

                        break;


                    case 'I':

                        if (currentReadPos > matchAreaStartPos) {
                            //
                            // This covers at least some of the match area
                            //
                            unsigned firstPos = __max(currentReadPos, matchAreaStartPos);
                            unsigned lastPos = __min(currentReadPos + cigarCount, matchAreaStartPos + matchAreaSize);

                            for (unsigned pos = firstPos; pos < lastPos; pos++) {
                                matchesReference &= (samPieces[Seq][offsetInRead + pos - currentReadPos] == referenceMatch[pos - matchAreaStartPos]);
                                matchesMutant &= (samPieces[Seq][offsetInRead + pos - currentReadPos] == mutantMatch[pos - matchAreaStartPos]);
                            }

                            if (currentReadPos == mutationStartPos) {
                                checkedMutationLocation = true;
                            }
                        }

                        offsetInRead += cigarCount;
                        break;

#endif // 0
                    case 'N':
                        currentReadPos += cigarCount;
                        break;

                    case 'H':
                        break;  // Hard clip; just telling us something's missing, it's a no-op for us.

                    default:
                        fprintf(stderr, "Invalid cigar operation %c in cigar string '%s' on line %d of SAM file '%s'\n", op, cigarString, samFileLineNumber, SAMFileName);
                        nSAMProblems++;
                        goto doneWithMutation;
                    } // switch


                    if (currentReadPos > mutationStartPos) {
                        break;
                    }
                } // While still processing CIGAR string

                if (checkedMutationLocation) {
                    if (matchesReference) {
                        if (matchesMutant) {
                            nMatchingBoth[pass]++;
                        }
                        else {
                            nMatchingReference[pass]++;
                        }
                    }
                    else if (matchesMutant) {
                        nMatchingMutation[pass]++;
                    }
                    else {
                        nMatchingNeither[pass]++;
                    }
                }

            } // For each line in the SAM file
        } // for each pass over the VCF-style line (only executes once for MAF-style)

        //
        // Write out the input line, but with the counts appended.  First strip the newline out of the raw input buffer.
        //

        char *newline = strchr(rawInputBuffer, '\n');
        if (NULL != newline) {
            *newline = '\0';
        }

        //
        // Now figure out the tumor type by extracting the first component of the pathname or reading it from the input line.
        //
        char cancerType[100];

        if (vcfStyleInput) {
            strcpy_s(cancerType, 100, piece[DiseaseType]);
        } else if (!selectedReadsStyleInput) {
            char *pathSep = strchr(piece[RNAFileName], '\\');
            if (NULL == pathSep) {
                strcpy_s(cancerType, 100, "Unknown");
            } else {
                *pathSep = '\0';
                strcpy_s(cancerType, 100, piece[RNAFileName]);
            }
        }

        if (vcfStyleInput) {
            printf("%s\t%s\t%d\t%d\t%d\t%d\t", cancerType, rawInputBuffer, nMatchingReference[0], nMatchingMutation[0], nMatchingNeither[0], nMatchingBoth[0]);
            if (hasNormalRNA) {
                printf("%d\t%d\t%d\t%d\n", nMatchingReference[1], nMatchingMutation[1], nMatchingNeither[1], nMatchingBoth[1]);
            }
            else {
                printf("\t\t\t\n");
            }
        } else if (germlineStyleInput || selectedReadsStyleInput) {
            printf("%s\t%d\t%d\t%d\t%d\t%d\t%d\t%d\t%d\n", rawInputBuffer, nMatchingReference[0], nMatchingMutation[0], nMatchingNeither[0], nMatchingBoth[0], nMatchingReference[1], nMatchingMutation[1], nMatchingNeither[1], nMatchingBoth[1]);
        } else {
            printf("%s\t%s\t%d\t%d\t%d\t%d\n", cancerType, rawInputBuffer, nMatchingReference[0], nMatchingMutation[0], nMatchingNeither[0], nMatchingBoth[0]);
        }

        doneWithMutation:
        mutationNumber++;
    } // for each line in the MAF/VCF-style file

    if (selectedReadsStyleInput && !seenDone) {
        fprintf(stderr, "Truncated selectedVariants intput file, **done** not seen.\n");
    } else {
        printf("**done**");
    }

    bool first = true;
    fprintf(stderr, "\n");
    while (NULL != missingGUIDs) {
        fprintf(stderr, "findstr %s extractTumorDNASamples.cmd >%c foo.cmd\n", missingGUIDs->guid, first ? ' ' : '>');
        first = false;
        missingGUIDs = missingGUIDs->next;  // Just leak, we're about to exit
    }

    fprintf(stderr, "%d mutations, %d mitochondrial, %d no SAM file, %d wrong class, %d validation problems, %d SAM file problems\n", mutationNumber, nMT, noSAMFile, nWrongClass, nValidationProblems, nSAMProblems);
}

