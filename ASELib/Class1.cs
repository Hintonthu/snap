using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.IO;
using System.Threading;
using System.IO.Compression;
using System.Net;
using System.Web;
using System.Runtime.Serialization;
using System.Runtime.Serialization.Json;
using System.Diagnostics;
using System.Runtime.InteropServices;

namespace ASELib
{
    public class ASETools
    {
        public const string urlPrefix = @"https://gdc-api.nci.nih.gov/";

        //
        // An entity is an object stored in the file system that's generated by the scripts made by the ASEProcessManager.
        //
        public class Entity
        {
        }

        //
        // A Case is a person with TCGA data.
        //
        public class Case
        {
            //
            // Mandatory metadata that's created by GenerateCases.
            //
            public string case_id;                                              // 0
            public string normal_dna_file_id;                                   // 1
            public string tumor_dna_file_id;                                    // 2
            public string normal_rna_file_id = "";    // This is optional       // 3
            public string tumor_rna_file_id;                                    // 4
            public string vcf_file_id;                                          // 5
            public string maf_file_id;                                          // 6
            public string methylation_file_id;                                  // 7
            public string project_id;   // This is TCGA_<DiseaseType> for TCGA. // 8

            //
            // Pathnames for downloaded files.
            //
            public string normal_dna_filename = "";                             // 9
            public string tumor_dna_filename = "";                              // 10
            public string normal_rna_filename = "";                             // 11
            public string tumor_rna_filename = "";                              // 12
            public string vcf_filename = "";                                    // 13
            public string methylation_filename = "";                            // 14

            //
            // Pathnames for generated files.
            //
            public string tumor_dna_allcount_filename = "";                     // 15
            public string tumor_rna_allcount_filename = "";                     // 16
            public string maf_filename = "";                                    // 17
            public string regional_expression_filename = "";                    // 18
            public string gene_expression_filename = "";                        // 19
            public string selected_variants_filename = "";                      // 20
            public string dna_reads_at_selected_variants_filename = "";         // 21
            public string rna_reads_at_selected_variants_filename = "";         // 22
            public string annotated_selected_variants_filename = "";            // 23
            public string allele_specific_gene_expression_filename = "";        // 24
            public string tumor_dna_gene_coverage_filname = "";                 // 25

            public static Dictionary<string, Case> LoadCases(string inputFilename)
            {
                if (!File.Exists(inputFilename))
                {
                    return null;   // Nothing to load because we haven't generated a cases file yet.
                }

                var wantedFields = new List<string>();
                wantedFields.Add("Case ID");
                wantedFields.Add("Normal DNA File ID");
                wantedFields.Add("Tumor DNA File ID");
                wantedFields.Add("Normal RNA File ID");
                wantedFields.Add("Tumor RNA File ID");
                wantedFields.Add("VCF File ID");
                wantedFields.Add("MAF File ID");
                wantedFields.Add("Methylation File ID");
                wantedFields.Add("Project ID");
                wantedFields.Add("Normal DNA Filename");
                wantedFields.Add("Tumor DNA Filename");
                wantedFields.Add("Normal RNA Filename");
                wantedFields.Add("Tumor RNA Filename");
                wantedFields.Add("VCF Filename");
                wantedFields.Add("Methylation Filename");
                wantedFields.Add("Tumor DNA Allcount Filename");
                wantedFields.Add("Tumor RNA Allcount Filename");
                wantedFields.Add("MAF Filename");
                wantedFields.Add("Regional Expression Filename");
                wantedFields.Add("Gene Expression Filename");
                wantedFields.Add("Selected Variants Filename");
                wantedFields.Add("DNA Reads At Selected Variants Filename");
                wantedFields.Add("RNA Reads At Selected Variants Filename");
                wantedFields.Add("Annotated Selected Variants Filename");
                wantedFields.Add("Allele Specific Gene Expression Filename");
                wantedFields.Add("Tumor DNA Gene Coverage Filename");

                var inputFile = CreateStreamReaderWithRetry(inputFilename);
                var headerizedFile = new HeaderizedFile<Case>(inputFile, false, true, "", wantedFields);

                List<Case> listOfCases;
                if (!headerizedFile.ParseFile(fromSaveFileLine, out listOfCases)) {
                    inputFile.Close();
                    return null;
                }

                inputFile.Close();

                var cases = new Dictionary<string, Case>();
                foreach (var case_ in listOfCases) {
                    cases.Add(case_.case_id, case_);
                }
 
                return cases;
            }

            static public Case fromSaveFileLine(Dictionary<string, int> fieldMappings, string[] fields)
            {
                var case_ = new Case();

                case_.case_id = fields[fieldMappings["Case ID"]];
                case_.normal_dna_file_id = fields[fieldMappings["Normal DNA File ID"]];
                case_.tumor_dna_file_id = fields[fieldMappings["Tumor DNA File ID"]];
                case_.normal_rna_file_id = fields[fieldMappings["Normal RNA File ID"]];
                case_.tumor_rna_file_id = fields[fieldMappings["Tumor RNA File ID"]];
                case_.vcf_file_id = fields[fieldMappings["VCF File ID"]];
                case_.maf_file_id = fields[fieldMappings["MAF File ID"]];
                case_.methylation_file_id = fields[fieldMappings["Methylation File ID"]];
                case_.project_id = fields[fieldMappings["Project ID"]];
                case_.normal_dna_filename = fields[fieldMappings["Normal DNA Filename"]];
                case_.tumor_dna_filename = fields[fieldMappings["Tumor DNA Filename"]];
                case_.normal_rna_filename = fields[fieldMappings["Normal RNA Filename"]];
                case_.tumor_rna_filename = fields[fieldMappings["Tumor RNA Filename"]];
                case_.vcf_filename = fields[fieldMappings["VCF Filename"]];
                case_.methylation_filename = fields[fieldMappings["Methylation Filename"]];
                case_.tumor_dna_allcount_filename = fields[fieldMappings["Tumor DNA Allcount Filename"]];
                case_.tumor_rna_allcount_filename = fields[fieldMappings["Tumor RNA Allcount Filename"]];
                case_.maf_filename = fields[fieldMappings["MAF Filename"]];
                case_.regional_expression_filename = fields[fieldMappings["Regional Expression Filename"]];
                case_.gene_expression_filename = fields[fieldMappings["Gene Expression Filename"]];
                case_.selected_variants_filename = fields[fieldMappings["Selected Variants Filename"]];
                case_.dna_reads_at_selected_variants_filename = fields[fieldMappings["DNA Reads At Selected Variants Filename"]];
                case_.rna_reads_at_selected_variants_filename = fields[fieldMappings["RNA Reads At Selected Variants Filename"]];
                case_.annotated_selected_variants_filename = fields[fieldMappings["Annotated Selected Variants Filename"]];
                case_.allele_specific_gene_expression_filename = fields[fieldMappings["Allele Specific Gene Expression Filename"]];
                case_.tumor_dna_gene_coverage_filname = fields[fieldMappings["Tumor DNA Gene Coverage Filename"]];
 
                return case_;
            }

            public string GenerateLine()
            {
                return case_id + "\t" + normal_dna_file_id + "\t" + tumor_dna_file_id + "\t" + normal_rna_file_id + "\t" + tumor_rna_file_id + "\t" + vcf_file_id + "\t" + maf_file_id + "\t" + methylation_file_id + "\t" + project_id + "\t" +
                    normal_dna_filename + "\t" + tumor_dna_filename + "\t" + normal_rna_filename + "\t" + tumor_rna_filename + "\t" + vcf_filename + "\t" + methylation_filename + "\t" + tumor_dna_allcount_filename + "\t" + tumor_rna_allcount_filename + "\t" +
                    maf_filename + "\t" + regional_expression_filename + "\t" + gene_expression_filename + "\t" +
                    selected_variants_filename + "\t" + dna_reads_at_selected_variants_filename + "\t" + rna_reads_at_selected_variants_filename + "\t" + annotated_selected_variants_filename + "\t" + 
                    allele_specific_gene_expression_filename + "\t" + tumor_dna_gene_coverage_filname;
            }

            public static void SaveToFile(Dictionary<string, Case> cases, string filename)
            {
                var file = CreateStreamWriterWithRetry(filename);
                Console.WriteLine(
                    "Case ID" + "\t" +
                    "Normal DNA File ID" + "\t" +
                    "Tumor DNA File ID" + "\t" +
                    "Normal RNA File ID" + "\t" +
                    "Tumor RNA File ID" + "\t" +
                    "VCF File ID" + "\t" +
                    "MAF File ID" + "\t" +
                    "Methylation File ID" + "\t" +
                    "Project ID" + "\t" +
                    "Normal DNA Filename" + "\t" +
                    "Tumor DNA Filename" + "\t" +
                    "Normal RNA Filename" + "\t" +
                    "Tumor RNA Filename" + "\t" +
                    "VCF Filename" + "\t" +
                    "Methylation Filename" + "\t" +
                    "Tumor DNA Allcount Filename" + "\t" +
                    "Tumor RNA Allcount Filename" + "\t" +
                    "MAF Filename" + "\t" +
                    "Regional Expression Filename" + "\t" +
                    "Gene Expression Filename" + "\t" +
                    "Selected Variants Filename" + "\t" +
                    "DNA Reads At Selected Variants Filename" + "\t" +
                    "RNA Reads At Selected Variants Filename" + "\t" +
                    "Annotated Selected Variants Filename" + "\t" +
                    "Allele Specific Gene Expression Filename" + "\t" +
                    "Tumor DNA Gene Coverage Filename");

                foreach (var case_ in cases)
                {
                    file.WriteLine(case_.Value.GenerateLine());
                }
                file.WriteLine("**done**");
                file.Close();
            }
        }

        public static StreamWriter CreateStreamWriterWithRetry(string filename)
        {
            while (true)
            {
                try
                {
                    var writer = new StreamWriter(filename);
                    return writer;
                }
                catch (IOException)
                {
                    Console.WriteLine("IOException opening " + filename + " for write.  Sleeping and retrying.");
                    Thread.Sleep(10 * 1000);
                }
            }
        }

        public static StreamReader CreateStreamReaderWithRetry(string filename)
        {
            while (true)
            {
                try
                {
                    var reader = new StreamReader(filename);
                    return reader;
                }
                catch (IOException)
                {
                    Console.WriteLine("IOException opening " + filename + " for read.  Sleeping and retrying.");
                    Thread.Sleep(10 * 1000);
                }
            }
        }

        public static StreamReader CreateCompressedStreamReaderWithRetry(string filename)
        {
            return new StreamReader(new GZipStream(CreateStreamReaderWithRetry(filename).BaseStream, CompressionMode.Decompress));
        }

        public static string[] ReadAllLinesWithRetry(string filename)
        {
            while (true)
            {
                try
                {
                    var lines = File.ReadAllLines(filename);
                    return lines;
                }
                catch (IOException)
                {
                    Console.WriteLine("IOException reading " + filename + ".  Sleeping and retrying.");
                    Thread.Sleep(10 * 1000);
                }
            }
        }

        public class ASEConfirguation
        {
            public const string defaultBaseDirectory = @"\\msr-genomics-0\d$\gdc\";
            public const string defaultConfigurationFilePathame = defaultBaseDirectory + "configuration.txt";

            public string accessTokenPathname = defaultBaseDirectory +  @"access_token.txt";
            public List<string> dataDirectories = new List<string>();
            public string mafManifestPathname = defaultBaseDirectory + "mafManifest.txt";
            public string mutationCaller = "mutect";
            public List<string> programNames = new List<string>();
            public string binaryDirectory = defaultBaseDirectory + @"bin\";
            public string configuationFilePathname = defaultConfigurationFilePathame;
            public string casesFilePathname = defaultBaseDirectory + "cases.txt";

            ASEConfirguation()
            {
                programNames.Add("TCGA");   // The default value
                dataDirectories.Add(defaultBaseDirectory + @"downloaded_files\");
            }

            //
            // Parse the args to find the configuration file pathname, and then load from that path (or the default if it's not present).
            //
            public static ASEConfirguation loadFromFile(string [] args) 
            {
                string pathname = @"\\msr-genomics-0\d$\gdc\configuration.txt";

                for (int i = 0; i < args.Count(); i++) {
                    if (args[i] == "-configuration") {
                        if (i >= args.Count() - 1) {
                            Console.WriteLine("-configuation can't be the last parameter, it needs to be followed by a file path.  Ignoring.");
                        } else {
                            pathname = args[i+1];
                        }
                    }
                }

                var retVal = new ASEConfirguation();

                if (!File.Exists(pathname))
                {
                    //
                    // No config file means to use the default.
                    //
                    return retVal;
                }

                retVal.configuationFilePathname = pathname; // Don't load this from the file, just keep track of where we got it from.

                var lines = ReadAllLinesWithRetry(pathname);
                bool seenProgramNames = false;
                bool seenDataDirectories = false;

                foreach (var line in lines) 
                {
                    var fields = line.Split('\t');
                    if (fields.Count() != 2) {
                        Console.WriteLine("ASEConfiguration.loadFromFile: configuration file " + pathname + " contains a line that doesn't have exactly two tab separated fields: " + line + ".  Ignoring.");
                        continue;
                    }

                    var type = fields[0].ToLower();
                    if (type == "access token") {
                        retVal.accessTokenPathname = fields[1];
                    } else if (type == "data directory") {
                        if (!seenDataDirectories)   // Don't keep the default
                        {
                            retVal.dataDirectories = new List<string>();
                            seenDataDirectories = true;
                        }
                        retVal.dataDirectories.Add(fields[1]);
                    } else if (type == "maf manifest") {
                        retVal.mafManifestPathname = fields[1];
                    } else if (type == "mutation caller") {
                        retVal.mutationCaller = fields[1];
                    } else if (type == "program name") {
                        if (!seenProgramNames)  // If we've got the default value, override it.
                        {
                            retVal.programNames = new List<string>();
                            seenProgramNames = true;
                        }

                        retVal.programNames.Add(fields[1]);
                    } else if (type == "binary directory") {
                        retVal.binaryDirectory = fields[1];
                    } else if (type == "cases") {
                        retVal.casesFilePathname = fields[1];
                    } else {
                        Console.WriteLine("ASEConfiguration.loadFromFile: configuration file " + pathname + " contains a line with an unknown configuration parameter type: " + line + ".  Ignoring.");
                        continue;
                    }
                }

                return retVal;
            }

        }

        public static System.Net.WebClient getWebClient()
        {
            ServicePointManager.SecurityProtocol = SecurityProtocolType.Tls12;  // NIH uses TLS v 1.2, and for some reason the auto negotiate doesn't pick that up, so we'll just set it explicitly

            var webClient = new WebClient();

            //
            // Check the status of gdc to make sure that we're in the right version.
            //

            var statusSerializer = new DataContractJsonSerializer(typeof(ASETools.Status));
            ASETools.Status status = (ASETools.Status)statusSerializer.ReadObject(new MemoryStream(webClient.DownloadData(ASETools.urlPrefix + "status")));

            if (status.status != "OK")
            {
                Console.WriteLine("GDC returned not OK status of " + status.status + ", aborting");
                return null;
            }

            if (status.version != "1")
            {
                Console.WriteLine("GDC returned a version number that we don't understand (" + status.version + ", you probably need to update this program.");
                return null;
            }

            return webClient;
        }

        [DataContract]
        public class Status
        {
            [DataMember]
            public string commit = "";  // Default values are to void having Visual Studio generate a warning, since it can't see that they're set by the JSON serializer

            [DataMember]
            public string status = "";

            [DataMember]
            public string tag = "";

            [DataMember]
            public string version = "";
        }

        [DataContract]
        public class GDCPagination
        {
            [DataMember]
            public int count = 0;

            [DataMember]
            public string sort = "";

            [DataMember]
            public int from = 0;

            [DataMember]
            public int page = 0;

            [DataMember]
            public int total = 0;

            [DataMember]
            public int pages = 0;

            [DataMember]
            public string size = "";

            static public GDCPagination extractFromString(string inputString)
            {
                int paginationIndex = inputString.IndexOf("\"pagination\":");

                if (-1 == paginationIndex)
                {
                    return null;
                }

                int openCurlyBraceIndex = paginationIndex;

                int size = inputString.Count();

                while (openCurlyBraceIndex < size && inputString[openCurlyBraceIndex] != '{')
                {
                    openCurlyBraceIndex++;
                }

                if (openCurlyBraceIndex >= size)
                {
                    return null;
                }

                int currentIndex = openCurlyBraceIndex + 1;
                int openCurlyBraceCount = 1;

                while (currentIndex < size && openCurlyBraceCount > 0)
                {
                    if (inputString[currentIndex] == '}')
                    {
                        openCurlyBraceCount--;
                    }
                    else if (inputString[currentIndex] == '{')
                    {
                        openCurlyBraceCount++;
                    }
                    currentIndex++;
                }

                if (0 != openCurlyBraceCount)
                {
                    throw new FormatException();
                }


                var paginationString = inputString.Substring(openCurlyBraceIndex, currentIndex - openCurlyBraceIndex);
                var serializer = new DataContractJsonSerializer(typeof(GDCPagination));
                return (GDCPagination)serializer.ReadObject(new MemoryStream(Encoding.ASCII.GetBytes(paginationString)));
            }
        }

        [DataContract]
        public class GDCCaseProject
        {
            [DataMember]
            public string project_id;
        }

        [DataContract]
        public class GDCCase
        {
            [DataMember]
            public string[] sample_ids = { };

            [DataMember]
            public string[] portion_ids = { };

            [DataMember]
            public string updated_datetime = "";

            [DataMember]
            public string created_datetime = "";

//            [DataMember]
//            public string[] submitter_aliquot_ids = { };

//            [DataMember]
//            public string[] submitter_portion_ids = { };

//            [DataMember]
//            public string[] submitter_analyte_ids = { };

//            [DataMember]
//            public string[] analyte_ids = { };

            [DataMember]
            public string submitter_id = "";

            [DataMember]
            public string case_id = "";

            [DataMember]
            public string state = "";

//            [DataMember]
//            public string[] aliquot_ids = { };

//            [DataMember]
//            public string[] slide_ids = { };

//            [DataMember]
//            public string[] submitter_sample_ids = { };

//            [DataMember]
//            public string[] submitter_slide_ids = { };

            [DataMember]
            public GDCCaseProject project = null;

            public const string fields = //"sample_ids,portion_ids,updated_datetime,created_datetime,submitter_aliquot_ids,submitter_portion_ids,submitter_analyte_ids,analyte_ids,submitter_id,case_id,state,aliquot_ids,slide_ids,submitter_sample_ids,submitter_slide_ids,project.project_id";
                "sample_ids,portion_ids,updated_datetime,created_datetime,submitter_id,case_id,state,project.project_id";
        }

        [DataContract]
        public class GDCHits<containedClass>
        {
            [DataMember]
            public containedClass[] hits = { };
        }

        [DataContract]
        public class GDCData<containedClass>
        {
            [DataMember]
            public GDCHits<containedClass> data = null;
        }

         [DataContract]
        public class GDCSamples
        {
            [DataMember]
            public string sample_type_id = "";

            [DataMember]
            public string sample_type = "";

            [DataMember]
            public string sample_id = "";
        }

        [DataContract]
        public class GDCFileCases
        {
            [DataMember]
            public GDCSamples[] samples = { };
        }

        [DataContract]
        public class GDCFileAnalysis
        {
            [DataMember]
            public string workflow_link = "";
        }

        [DataContract]
        public class GDCFile
        {
            [DataMember]
            public string data_type = "";

            [DataMember]
            public string updated_datetime = "";

            [DataMember]
            public string created_datetime = "";

            [DataMember]
            public string file_name = "";

            [DataMember]
            public string md5sum = "";

            [DataMember]
            public string data_format = "";

            [DataMember]
            public string[] acl = { };

            [DataMember]
            public string access = "";

            [DataMember]
            public string platform = "";

            [DataMember]
            public string state = "";

            [DataMember]
            public string file_id = "";

            [DataMember]
            public string data_category = "";

            [DataMember]
            public long file_size = 0;

            [DataMember]
            public string submitter_id = "";

            [DataMember]
            public string type = "";

            [DataMember]
            public string file_state = "";

            [DataMember]
            public string experimental_strategy = "";

            [DataMember]
            public GDCFileCases[] cases = { };

            [DataMember]
            public GDCFileAnalysis analysis = null;

            public static GDCFile selectNewestUpdated(GDCFile one, GDCFile two)
            {
                if (null == one) return two;
                if (null == two) return one;

                if (Convert.ToDateTime(one.updated_datetime) < Convert.ToDateTime(two.updated_datetime))
                {
                    return two;
                }
                else
                {
                    return one;
                }
            }
        } // GDCFile


        public static string generateFilterList(List<string> itemsToAdd)
        {
            var outputString = "[";

            bool addedOneAlready = false;
            foreach (var item in itemsToAdd)
            {
                if (addedOneAlready)
                {
                    outputString += ",";
                }
                else
                {
                    addedOneAlready = true;
                }
                outputString += "\"" + item + "\"";
            }

            outputString += "]";

            return outputString;
        }

        public static string ElapsedTimeInSeconds(Stopwatch stopwatch)
        {
            return "" + (stopwatch.ElapsedMilliseconds + 500) / 1000 + "s";
        }

        public static string GetFileNameFromPathname(string pathname, bool excludeExtension = false)
        {
            string lastComponent;
            if (pathname.LastIndexOf('\\') == -1)
            {
                lastComponent = pathname;
            }
            else
            {
                lastComponent = pathname.Substring(pathname.LastIndexOf('\\') + 1);
            }

            if (!excludeExtension || lastComponent.LastIndexOf('.') == -1)
            {
                return lastComponent;
            }

            return lastComponent.Substring(0, lastComponent.LastIndexOf('.'));
        }

        public class DownloadedFile
        {
            public readonly string file_id;
            public FileInfo fileInfo;
            public readonly string storedMd5Sum;    // This is the null string for files for which we don't know the sum (i.e., they haven't yet been computed or we don't know the right answer).
            public string expectedMd5Sum = "";      // This gets set later if we know the correct answer.

            public DownloadedFile(string file_id_, string pathname, string storedMd5Sum_)
            {
                file_id = file_id_;
                storedMd5Sum = storedMd5Sum_;

                fileInfo = new FileInfo(pathname);
            }

            //
            // Grovel the file system(s) to look for downloaded files.  Returns a dictionary that maps from file_id -> DownloadedFile object.
            //
            public static Dictionary<string, DownloadedFile> ScanFilesystems(ASEConfirguation configuration)
            {
                var downloadedFiles = new Dictionary<string, DownloadedFile>();

                foreach (var directory in configuration.dataDirectories)
                {
                    foreach (var subdir in Directory.EnumerateDirectories(directory))
                    {
                        var file_id = GetFileNameFromPathname(subdir).ToLower();    // The directory is the same as the file id.

                        if (downloadedFiles.ContainsKey(file_id))
                        {
                            Console.WriteLine("Found duplicate downloaded files (or at least directories) at " + subdir + " and " + downloadedFiles[file_id].fileInfo.FullName);
                            continue;
                        }

                        //
                        // Look through the subdirectory to find the downloaded file and also any .md5 versions of it.
                        //
                        string candidatePathname = null;
                        string md5Pathname = null;
                        foreach (var pathname in Directory.EnumerateFiles(subdir))
                        {
                            var filename = GetFileNameFromPathname(pathname).ToLower();
                            if (filename == "annotations.txt")
                            {
                                continue;
                            }

                            if (filename.Count() > 4 && filename.Substring(filename.Count() - 4) == ".md5")
                            {
                                if (null != md5Pathname)
                                {
                                    Console.WriteLine("Directory " + subdir + " contains more than one file with extension .md5");
                                    continue;
                                }
                                md5Pathname = pathname;
                                continue;
                            }

                            if (null != candidatePathname)
                            {
                                Console.WriteLine("Found more than one file candidate in " + subdir);
                                continue;
                            }

                            candidatePathname = pathname;
                        }

                        if (candidatePathname == null && md5Pathname != null)
                        {
                            Console.WriteLine("Found md5 file in directory without accompanying downloaded file (?): " + md5Pathname);
                            continue;
                        }

                        string md5Value = "";
                        if (md5Pathname != null)
                        {
                            if (md5Pathname.ToLower() != candidatePathname.ToLower() + ".md5")
                            {
                                Console.WriteLine("md5 file has wrong basename: " + md5Pathname);
                            }
                            else
                            {
                                var lines = ReadAllLinesWithRetry(md5Pathname);
                                if (lines.Count() != 1 || lines[0].Count() != 32)
                                {
                                    Console.WriteLine("md5 file " + md5Pathname + " has a non-md5 content.  Ignoring.");
                                }
                                else
                                {
                                    md5Value = lines[0];
                                }
                            }
                        }

                        downloadedFiles.Add(file_id, new DownloadedFile(file_id, candidatePathname, md5Value));
                    }
                }

                return downloadedFiles;
            } // ScanFilesystems
        } // DownloadedFile


        public class MAFInfo
        {
            public MAFInfo(string file_id_, string md5Sum_, string filename_)
            {
                file_id = file_id_;
                md5Sum = md5Sum_;
                filename = filename_;
            }
            public static MAFInfo fromSaveFileLine(string saveFileLine)
            {
                var fields = saveFileLine.Split('\t');

                if (fields.Count() != 3)
                {
                    Console.WriteLine("Incorrect number of fields in maf configuration file line: " + saveFileLine);
                    return null;
                }

                return new MAFInfo(fields[0], fields[1], fields[2]);
            }

            public static Dictionary<string, MAFInfo> LoadMAFManifest(string filename)
            {
                if (!File.Exists(filename))
                {
                    return null;
                }

                var lines = ReadAllLinesWithRetry(filename);

                if (lines.Count() < 2)
                {
                    Console.WriteLine("MAF manifest file " + filename + " has too few lines.  Ignoring.");
                    return null;
                }

                var headerPrefix = "MAF Manifest v1.0 generated at ";
                if (lines[0].Count() < headerPrefix.Count() || lines[0].Substring(0,headerPrefix.Count()) != headerPrefix) {
                    Console.WriteLine("Corrupt or unrecognized version in maf manifest header, ignoring: " + lines[0]);
                    return null;
                }

                var retVal = new Dictionary<string, MAFInfo>();

                if (lines[lines.Count() -1] != "**done**") {
                    Console.WriteLine("maf manifest file " + filename + " does not end with **done**, and so is probably truncated.  Ignoring.");
                    return null;
                }

                for (int i = 1; i < lines.Count() - 1; i++) {
                    var mafInfo = MAFInfo.fromSaveFileLine(lines[i]);

                    if (null == mafInfo) {
                        Console.WriteLine("failed to parse maf manifest line " + lines[i] + ".  Ignoring configuration file.");
                        return null;
                    }

                    if (retVal.ContainsKey(mafInfo.file_id)) {
                        Console.WriteLine("Duplicate file id " + mafInfo.file_id + " in maf manifest file " + filename);
                        return null;
                    }

                    retVal.Add(mafInfo.file_id, mafInfo);
                }

                return retVal;
            }

            public string file_id;
            public string md5Sum;
            public string filename;
        }

        //
        // Code for GetVolumeFreeSpace adapted from http://stackoverflow.com/questions/14465187/get-available-disk-free-space-for-a-given-path-on-windows
        //
        [DllImport("kernel32.dll", SetLastError = true, CharSet = CharSet.Auto)]
        [return: MarshalAs(UnmanagedType.Bool)]
        static extern bool GetDiskFreeSpaceEx(string lpDirectoryName,
           out ulong lpFreeBytesAvailable,
           out ulong lpTotalNumberOfBytes,
           out ulong lpTotalNumberOfFreeBytes);
        public static ulong GetVolumeFreeSpace(string pathname)
        {
            ulong FreeBytesAvailable;
            ulong TotalNumberOfBytes;
            ulong TotalNumberOfFreeBytes;

            if (!GetDiskFreeSpaceEx(pathname,
                                        out FreeBytesAvailable,
                                        out TotalNumberOfBytes,
                                        out TotalNumberOfFreeBytes))
            {
                throw new System.ComponentModel.Win32Exception();
            }

            return FreeBytesAvailable;
        }

        public class HeaderizedFile<outputType>
        {
            public delegate outputType Parse(Dictionary<string, int> fieldMappings, string[] fields);
            public HeaderizedFile(StreamReader inputFile_, bool hasVersion_, bool hasDone_, string expectedVersion_, List<string> wantedFields_)
            {
                inputFile = inputFile_;
                hasVersion = hasVersion_;
                hasDone = hasDone_;
                expectedVersion = expectedVersion_;
                wantedFields = wantedFields_;
            }

            public bool ParseFile(Parse parser, out List<outputType> result)
            {
                if (hasVersion)
                {
                    var versionString = inputFile.ReadLine();

                    if (versionString == null || expectedVersion != null && versionString != expectedVersion)
                    {
                        result = null;
                        return false;
                    }
                }

                var header = inputFile.ReadLine();
                if (null == header)
                {
                    result = null;
                    return false;
                }

                var columns = header.Split('\t');
                var fieldMappings = new Dictionary<string, int>();
                int maxNeededField = -1;

                for (int i = 0; i < columns.Count(); i++)
                {
                    if (wantedFields.Contains(columns[i]))
                    {
                        if (fieldMappings.ContainsKey(columns[i]))
                        {
                            Console.WriteLine("Duplicate needed column in headerized file (or code bug or something): " + columns[i]);
                            result = null;
                            return false;
                        }
                        
                        fieldMappings.Add(columns[i], i);
                        maxNeededField = i;
                    }
                }

                if (fieldMappings.Count() != wantedFields.Count())
                {
                    Console.WriteLine("Headerized file: missing some columns.");
                    result = null;
                    return false;
                }

                string inputLine;
                bool sawDone = false;
                result = new List<outputType>();
                while (null != (inputLine = inputFile.ReadLine())) {
                    if (sawDone) {
                        Console.WriteLine("HeaderizedFile: Saw data after **done**");
                        result = null;
                        return false;
                    }

                    if ("**done**" == inputLine) {
                        sawDone = true;
                        continue;
                    }

                    var fields = inputLine.Split('\t');
                    if (fields.Count() <= maxNeededField)
                    {
                        Console.WriteLine("HeaderizedFile.Parse: input line didn't include a needed field " + inputLine);
                        result = null;
                        return false;
                    }

                    result.Add(parser(fieldMappings, fields));
                }

                if (hasDone && !sawDone)
                {
                    Console.WriteLine("HeaderizedFile.Parse: missing **done**");
                    result = null;
                    return false;
                }
                else if (!hasDone && sawDone)
                {
                    Console.WriteLine("Saw unepected **done**.  Ignoring.");
                    result = null;
                    return false;
                }

                return true;
            } // ParseFile

            StreamReader inputFile;
            bool hasVersion;
            bool hasDone;
            string expectedVersion;
            List<string> wantedFields;
        } // HeaderizedFile

        public class MAFLine
        {
            public readonly string Hugo_Symbol;
            public readonly string NCBI_Build;
            public readonly string Chromosome;
            public readonly int Start_Position;
            public readonly int End_Positon;
            public readonly string Variant_Classification;
            public readonly string Variant_Type;
            public readonly string Reference_Allele;
            public readonly string Tumor_Seq_Allele1;
            public readonly string Tumor_Seq_Allele2;
            public readonly string Match_Norm_Seq_Allele1;
            public readonly string Match_Norm_Seq_Allele2;
            public readonly string Tumor_Sample_UUID;
            public readonly string Matched_Norm_Sample_UUID;
            public readonly string file_id; // Of the MAF file

            MAFLine(string Hugo_Symbol_, 
             string NCBI_Build_,
             string Chromosome_,
             int Start_Position_,
             int End_Positon_,
             string Variant_Classification_,
             string Variant_Type_,
             string Reference_Allele_,
             string Tumor_Seq_Allele1_,
             string Tumor_Seq_Allele2_,
             string Match_Norm_Seq_Allele1_,
             string Match_Norm_Seq_Allele2_,
             string Tumor_Sample_UUID_,
             string Matched_Norm_Sample_UUID_,
             string file_id_)
            {
                Hugo_Symbol = Hugo_Symbol_;
                NCBI_Build = NCBI_Build_;
                Chromosome = Chromosome_;
                Start_Position = Start_Position_;
                End_Positon = End_Positon_;
                Variant_Classification = Variant_Classification_;
                Variant_Type = Variant_Type_;
                Reference_Allele = Reference_Allele_;
                Tumor_Seq_Allele1 = Tumor_Seq_Allele1_;
                Tumor_Seq_Allele2_ = Tumor_Seq_Allele2;
                Match_Norm_Seq_Allele1 = Match_Norm_Seq_Allele1_;
                Match_Norm_Seq_Allele2 = Match_Norm_Seq_Allele2_;
                Tumor_Sample_UUID = Tumor_Sample_UUID_;
                Matched_Norm_Sample_UUID = Matched_Norm_Sample_UUID_;
                file_id = file_id_;
            }

            static MAFLine ParseLine(Dictionary<string, int> fieldMappings, string[] fields, string file_id)
            {
                return new MAFLine(
                    fields[fieldMappings["Hugo_Symbol"]],
                    fields[fieldMappings["NCBI_Build"]],
                    fields[fieldMappings["Chromosome"]],
                    Convert.ToInt32(fields[fieldMappings["Start_Position"]]),
                    Convert.ToInt32(fields[fieldMappings["End_Position"]]),
                    fields[fieldMappings["Variant_Classification"]],
                    fields[fieldMappings["Variant_Type"]],
                    fields[fieldMappings["Reference_Allele"]],
                    fields[fieldMappings["Tumor_Seq_Allele1"]],
                    fields[fieldMappings["Tumor_Seq_Allele2"]],
                    fields[fieldMappings["Match_Norm_Seq_Allele1"]],
                    fields[fieldMappings["Match_Norm_Seq_Allele2"]],
                    fields[fieldMappings["Tumor_Sample_UUID"]],
                    fields[fieldMappings["Matched_Norm_Sample_UUID"]],
                    file_id
                    );
            }

            static public List<MAFLine> ReadFile(string filename, string file_id)
            {
                var compressedStreamReader = CreateStreamReaderWithRetry(filename);

                var inputFile = new StreamReader(new GZipStream(compressedStreamReader.BaseStream, CompressionMode.Decompress));

                var neededFields = new List<string>();
                neededFields.Add("Hugo_Symbol");
                neededFields.Add("NCBI_Build");
                neededFields.Add("Chromosome");
                neededFields.Add("Start_Position");
                neededFields.Add("End_Position");
                neededFields.Add("Variant_Classification");
                neededFields.Add("Variant_Type");
                neededFields.Add("Reference_Allele");
                neededFields.Add("Tumor_Seq_Allele1");
                neededFields.Add("Tumor_Seq_Allele2");
                neededFields.Add("Match_Norm_Seq_Allele1");
                neededFields.Add("Match_Norm_Seq_Allele2");
                neededFields.Add("Tumor_Sample_UUID");
                neededFields.Add("Matched_Norm_Sample_UUID");

                var headerizedFile = new HeaderizedFile<MAFLine>(inputFile, true, false, "#version 2.4", neededFields);

                List<MAFLine> result;

                if (!headerizedFile.ParseFile((a, b) => ParseLine(a, b, file_id), out result))
                {
                    Console.WriteLine("Error reading MAF File " + filename);
                    return null;
                }

                inputFile.Close();
                compressedStreamReader.Close();

                return result;
            }

        }

    } // ASETools
}
